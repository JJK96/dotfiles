#!/usr/bin/env python
# manage netns namespaces that are connected to internet or other interfaces
from dataclasses import dataclass
import os
from subprocess import check_output
import re
import logging
from get_free_iprange import IPv4Network, get_free_iprange
from pathlib import Path

NAMESERVER = "8.8.8.8"
NAMESPACES_DIR = Path("/run/ns")

def bash_escape(string):
    return string.replace("'", "'\"'\"'")

def interface_exists(interface):
    return os.system(f"ip link | grep -q {interface}") == 0

def run(cmd):
    logging.debug(f"Running command: {cmd}")
    return os.system(cmd)

def ensure_namespace_dir():
    NAMESPACES_DIR.mkdir(parents=True, exist_ok=True)
    if not NAMESPACES_DIR.is_mount():
        run(f"mount -t tmpfs --make-private tmpfs {NAMESPACES_DIR}")

def get_iptables_table(nat=False):
    cmd = ["iptables"]
    if nat:
        cmd += ["-t", "nat"]
    cmd += ["-S"]
    entries = check_output(cmd)
    return entries.decode().splitlines()

def get_iptables_base_command(nat=False):
    cmd = "iptables "
    if nat:
        cmd += "-t nat "
    return cmd

def get_iptables_rules(nat=False):
    for line in get_iptables_table(nat=nat):
        if line.startswith("-A"):
            yield line

def get_iptables_chains(nat=False):
    for line in get_iptables_table(nat=nat):
        if line.startswith("-N"):
            yield line


def delete_iptables_entry(entry, nat=False):
    entry = re.sub(r"^-A", "-D", entry)
    entry = re.sub(r"^-N", "-X", entry)
    cmd = get_iptables_base_command(nat=nat) + entry
    run(cmd)


def delete_matching_iptables_rules(interface, nat=False):
    rules = get_iptables_rules(nat=nat)
    for rule in rules:
        if interface in rule:
            delete_iptables_entry(rule, nat=nat)


def delete_iptables_chain(chain, nat=False):
    chains = list(get_iptables_chains(nat=nat))
    if f"-N {chain}" not in chains:
        return
    base_cmd = get_iptables_base_command(nat=nat)
    entries = get_iptables_table(nat=nat)
    for entry in entries:
        if entry.endswith(f"-j {chain}"):
            delete_iptables_entry(entry, nat=nat)
    run(base_cmd + f"-F {chain}")
    run(base_cmd + f"-X {chain}")
    
def get_ip_range_from_interface(interface):
    output = check_output(f"ip addr show {interface}", shell=True).decode()
    match = re.search(r"inet ([^ ]+)", output)
    if match:
        return match.group(1)
    return None

def get_gateway_from_interface(interface):
    output = check_output("ip route", shell=True).decode()
    for line in output.splitlines():
        if line.startswith("default") and interface in line:
            parts = line.split()
            gateway_index = parts.index("via") + 1
            return parts[gateway_index]
    return None


@dataclass
class Namespace:
    name: str
    # Connected interface in the host
    host_interface: str = "host"
    host_addr: str = None
    namespace_addr: str = None
    iprange: IPv4Network = None

    @property
    def netns_path(self):
        return Path('/run/netns') / self.name

    @property
    def dir(self):
        return NAMESPACES_DIR / self.name

    @property
    def namespace_interface(self):
        return f"veth-{self.name}"

    @property
    def bridge_interface(self):
        return f"br-{self.name}"

    def add_netns(self):
        self.netns_path.touch()
        run(f"mount -o bind {self.dir}/net {self.netns_path}")

    def delete_netns(self):
        if self.netns_path.exists():
            run(f"umount {self.netns_path}")
            self.netns_path.unlink()

    def add_dns(self):
        with open(self.dir / 'resolv.conf', 'w') as f:
            f.write(f"nameserver {NAMESERVER}\n")
        self.run(f"mount -o bind {self.dir}/resolv.conf /etc/resolv.conf")

    def create(self):
        ensure_namespace_dir()
        self.dir.mkdir()
        for file in ["net", "mnt"]:
            (self.dir / file).touch()
        run(f"unshare --net={self.dir}/net --mount={self.dir}/mnt echo -n")
        self.add_netns()
        run(f"ip link add {self.namespace_interface} type veth peer name {self.host_interface} netns {self.name}")
        run(f"ip link set {self.namespace_interface} up")
        self.run(f"ip link set {self.host_interface} up")
        self.add_dns()

    def delete(self):
        self.delete_netns()
        for file in ["net", "mnt"]:
            file = self.dir / file
            if file.exists():
                run(f"umount {file}")
                file.unlink()
        (self.dir / 'resolv.conf').unlink(missing_ok=True)
        self.dir.rmdir()
        if interface_exists(self.bridge_interface):
            run(f"ip link delete {self.bridge_interface}")
        delete_matching_iptables_rules(self.namespace_interface, nat=True)
        delete_matching_iptables_rules(self.namespace_interface, nat=False)
        delete_iptables_chain(self.name, nat=True)
        delete_iptables_chain(self.name, nat=False)
        run(f"routing_table delete {self.name}")

    def run(self, cmd):
        return run(f"nsenter -n{self.dir}/net -m{self.dir}/mnt {cmd}")

    def set_addresses(self):
        if self.host_addr or self.namespace_addr:
            # Already done
            return
        self.iprange=get_free_iprange()
        hosts = self.iprange.hosts()
        self.host_addr=next(hosts)
        self.namespace_addr=next(hosts)
        run(f"ip addr add {self.host_addr}/{self.iprange.prefixlen} dev {self.namespace_interface}")
        self.run(f"ip addr add {self.namespace_addr}/{self.iprange.prefixlen} dev {self.host_interface}")

    def allow_forwarding(self):
        run(f"iptables -A FORWARD -i {self.namespace_interface} -j ACCEPT")
        run(f"iptables -A FORWARD -o {self.namespace_interface} -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT")

    def add_nat(self):
        self.set_addresses()
        self.allow_forwarding()
        self.run(f"ip route add default via {self.host_addr}")
        run(f"iptables -t nat -A POSTROUTING -s {self.namespace_addr} ! -o {self.namespace_interface} -j MASQUERADE")

    def forward(self, destination_ip):
        self.set_addresses()
        self.allow_forwarding()
        self.run(f"ip route add default via {self.host_addr}")
        run(f"routing_table add {self.name}")
        run(f"ip rule add iif {self.namespace_interface} lookup {self.name}")
        run(f"ip route add default via {destination_ip} table {self.name}")

    def add_bridge(self, egress_interface):
        egress_range = get_ip_range_from_interface(egress_interface)
        egress_gateway = get_gateway_from_interface(egress_interface)
        run(f"ip link add {self.bridge_interface} type bridge")
        run(f"ip link set {self.namespace_interface} master {self.bridge_interface}")
        run(f"ip link set {egress_interface} master {self.bridge_interface}")
        run(f"ip link set {self.bridge_interface} up")
        if egress_range:
            run(f"ip addr add {egress_range} dev {self.bridge_interface}")
            self.run(f"ip addr add {egress_range} dev {self.host_interface}")
            run(f"ip addr delete {egress_range} dev {egress_interface}")
        if egress_gateway:
            run(f"ip route add default via {egress_gateway}")
            self.run(f"ip route add default via {egress_gateway}")
        else:
            self.run(f"ip route add default dev {egress_interface}")


def main():
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--debug", action="store_true", help="Enable debug logging")
    subparsers = parser.add_subparsers(dest="command")
    add_parser = subparsers.add_parser("add", help="Create a new network namespace")
    add_parser.add_argument("namespace")
    add_parser.add_argument("--bridge", help="Bridge this interface to the veth pipe")
    add_parser.add_argument("--nat", action="store_true", help="Forward the veth interface to this interface using NAT")
    add_parser.add_argument("--forward", help="Forward traffic from this namespace to the specified destination IP")

    delete_parser = subparsers.add_parser("delete", help="Delete a network namespace")
    delete_parser.add_argument("namespace")

    exec_parser = subparsers.add_parser("exec", help="Enter a network namespace")
    exec_parser.add_argument("namespace")
    exec_parser.add_argument("cmd", nargs=argparse.REMAINDER, help="Command to run inside the namespace, if omitted starts the user's shell")

    args, extra_args = parser.parse_known_args()
    if os.geteuid() != 0:
        exit("You need to have root privileges to run this script.\nPlease try again, this time using 'sudo'. Exiting.")

    if args.debug:
        logging.basicConfig(level=logging.DEBUG)

    if args.command == "add":
        ns = Namespace(args.namespace)
        ns.create()
        if args.nat:
            ns.add_nat()
        if args.bridge:
            ns.add_bridge(args.bridge)
        if args.forward:
            ns.forward(args.forward)
    elif args.command == "delete":
        ns = Namespace(args.namespace)
        ns.delete()
    elif args.command == "exec":
        ns = Namespace(args.namespace)
        cmd = "su - $SUDO_USER"
        if args.cmd:
            cmd += " -c '" + bash_escape(" ".join(args.cmd)) + "'"
        ns.run(cmd)

if __name__ == "__main__":
    main()
